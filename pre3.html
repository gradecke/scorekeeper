<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Scorekeeper</title>

<!-- Chart.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
  /* Default (light) variables */
  :root{
    --bg: #f2f2f7;
    --card: #ffffff;
    --text: #111;
    --muted: #6b6b70;
    --border: #d0d0d6;
    --primary: #007AFF;
    --danger: #ff3b30;
  }

  /* Dark overrides applied by .theme-dark class */
  .theme-dark {
    --bg: #000000;
    --card: #1c1c1e;
    --text: #f2f2f7;
    --muted: #a9a9ae;
    --border: #303034;
    --primary: #0a84ff;
    --danger: #ff453a;
  }

  /* Light override (for forced light) */
  .theme-light {
    --bg: #f2f2f7;
    --card: #ffffff;
    --text: #111;
    --muted: #6b6b70;
    --border: #d0d0d6;
    --primary: #007AFF;
    --danger: #ff3b30;
  }

  html, body {
    height: 100%;
  }

  body{
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, system-ui, sans-serif;
    margin: 0;
    padding: 16px;
    background: var(--bg);
    color: var(--text);
    max-width: 820px;
    margin-left: auto;
    margin-right: auto;
    -webkit-text-size-adjust: 100%;
    overflow-y: auto;
  }

  h1{ text-align:center; margin: 6px 0 14px; font-size:20px; }

  .card{
    background: var(--card);
    border-radius: 12px;
    padding: 12px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.06);
    margin-bottom: 14px;
    border: 1px solid rgba(0,0,0,0.02);
  }

  /* Top bar */
  .topbar {
    display:flex;
    justify-content:flex-end;
    gap: 8px;
    align-items:center;
    margin-bottom: 8px;
  }

  .btn {
    background: var(--primary);
    color: white;
    padding: 10px 12px;
    border-radius: 10px;
    border: none;
    font-weight: 600;
    font-size: 15px;
  }

  .icon-btn {
    background: var(--card);
    color: var(--text);
    border: 1px solid var(--border);
    padding: 8px 10px;
    border-radius: 10px;
    font-size: 16px;
    display:inline-flex;
    align-items:center;
    gap:8px;
  }

  .actions-container { position: relative; display:inline-block; }

  .actions-menu {
    position: absolute;
    right: 0;
    top: 44px;
    background: var(--card);
    border: 1px solid var(--border);
    box-shadow: 0 6px 18px rgba(0,0,0,0.12);
    border-radius: 10px;
    min-width: 220px;
    z-index: 120;
    padding: 8px;
  }
  .actions-menu button { 
    display:block; 
    width:100%; 
    background: transparent; 
    border: none; 
    padding: 10px 8px; 
    text-align:left; 
    color: var(--text); 
    border-radius:8px;
    font-weight:600;
  }
  .actions-menu button:hover{ background: rgba(0,0,0,0.04); }

  /* Setup */
  #playerInputs .player-input-row { margin-bottom:10px; overflow:hidden; }
  input.player-name {
    width:100%;
    padding:10px;
    border-radius:10px;
    border:1px solid var(--border);
    background: var(--card);
    color: var(--text);
    font-size:15px;
    box-sizing: border-box;   /* important to avoid overflow */
    max-width:100%;           /* avoid exceeding viewport */
    -webkit-appearance: none;
  }

  .table {
    width:100%;
    border-collapse:collapse;
  }

  .table th, .table td {
    padding: 10px 8px;
    border-bottom: 1px solid var(--border);
    vertical-align: middle;
  }

  .table th {
    font-size: 14px;
    font-weight: 700;
    text-align: left;
    cursor: default;
  }

  .col-name { width: 55%; }
  .col-input { width: 25%; text-align:center; }
  .col-total { width: 20%; text-align:right; }

  .numeric-input {
    width: 84px;
    padding:8px;
    border-radius:8px;
    border:1px solid var(--border);
    font-size:15px;
    text-align:center;
    box-sizing: border-box;
    -webkit-appearance: none;
  }

  .color-dot {
    width:12px;
    height:12px;
    border-radius:50%;
    display:inline-block;
    margin-right:8px;
    vertical-align: middle;
  }

  .sort-icon {
    margin-left:8px;
    font-weight:800;
    color: var(--muted);
    font-size:14px;
    cursor: pointer;
    user-select: none;
  }

  /* Chart container */
  .chart-wrap {
    height: 40vh;
    max-height: 50vh;
    min-height: 180px;
    margin-top: 12px;
    overflow: hidden;
    position: relative;
  }
  canvas { width:100% !important; height:100% !important; display:block; }

  /* modal for editing rounds */
  .modal-backdrop {
    position: fixed;
    left:0; right:0; top:0; bottom:0;
    background: rgba(0,0,0,0.4);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index: 9999;
  }
  .modal {
    width: 95%;
    max-width: 900px;
    max-height: 85vh;
    overflow:auto;
    background: var(--card);
    border-radius: 12px;
    padding: 12px;
    border: 1px solid var(--border);
  }
  .modal .modal-actions { display:flex; gap:8px; justify-content:flex-end; margin-top:8px; }
  .modal table { width:100%; border-collapse:collapse; margin-top:8px; }
  .modal table th, .modal table td { padding:8px; border-bottom:1px solid var(--border); font-size:14px; text-align:center; }
  .modal input.round-input { width:70px; padding:6px; border-radius:6px; border:1px solid var(--border); text-align:center; box-sizing:border-box; }

  /* small screens */
  @media (max-width:420px){
    .col-name{ width: 60%; }
    .col-input{ width: 25%; }
    .col-total{ width: 15%; font-size:14px; }
    .numeric-input{ width:70px; padding:6px; }
  }

  .muted { color: var(--muted); font-size:13px; margin-top:6px; }
</style>
</head>
<body>

<h1>Scorekeeper</h1>

<!-- Top bar -->
<div class="topbar">
  <div class="actions-container">
    <button class="icon-btn" onclick="toggleActions()">Actions â–¾</button>
    <div id="actionsMenu" class="actions-menu" style="display:none;">
      <button onclick="confirmNewGame()">New Game (Same Players)</button>
      <button onclick="confirmReset()">Reset (New Players)</button>
      <button onclick="openEditRounds()">Edit Previous Rounds</button>
    </div>
  </div>

  <button id="themeToggle" class="icon-btn" title="Toggle theme" aria-label="Toggle theme">ðŸŒ™</button>
</div>

<!-- Setup -->
<div id="setup" class="card">
  <div id="playerInputs"></div>

  <div style="display:flex; gap:8px; margin-top:8px;">
    <button class="btn" style="flex:1" onclick="addPlayerInput()">Add Player</button>
    <button class="btn" style="flex:1;" onclick="startGame()">Start Game</button>
  </div>
  <div class="muted">Tip: Add player names, then press Start Game. Add at least one player.</div>
</div>

<!-- Game -->
<div id="game" class="card" style="display:none;">
  <table class="table" role="table" aria-label="Players table">
    <thead>
      <tr>
        <th class="col-name">Name
          <span id="nameSort" class="sort-icon" onclick="toggleSort('name')">â†“</span>
        </th>
        <th class="col-input">Points</th>
        <th class="col-total">Total
          <span id="scoreSort" class="sort-icon" onclick="toggleSort('score')">â†“</span>
        </th>
      </tr>
    </thead>
    <tbody id="playerRows"></tbody>
  </table>

  <div style="margin-top:10px;">
    <button class="btn" onclick="submitPoints()">Add Points</button>
  </div>

  <div class="chart-wrap card" style="margin-top:12px; padding:10px;">
    <canvas id="scoreChart"></canvas>
  </div>
</div>

<!-- Modal placeholder -->
<div id="modalContainer" style="display:none;"></div>

<script>
/* ------------------------------
   Config + state
   ------------------------------ */
const COLORS = [
  "#007AFF",
  "#FF3B30",
  "#34C759",
  "#AF52DE",
  "#FF9500",
  "#5AC8FA"
];

let players = [];
let scores = {};
let history = []; // each snapshot is array same order as players[]
let sortMode = "score-desc";
let chart = null;
let savedTheme = null;

/* ------------------------------
   Storage & Theme helpers
   ------------------------------ */
function saveState(){
  const state = { players, scores, history, sortMode, theme: savedTheme };
  try { localStorage.setItem("scorekeeper_state", JSON.stringify(state)); } catch(e){}
}

function loadState(){
  try{
    const raw = localStorage.getItem("scorekeeper_state");
    if(!raw) return false;
    const s = JSON.parse(raw);
    if(!s.players) return false;
    players = s.players || [];
    scores = s.scores || {};
    history = s.history || [];
    sortMode = s.sortMode || "score-desc";
    savedTheme = s.theme === undefined ? null : s.theme;
    return true;
  } catch(e){
    return false;
  }
}

/* Apply theme: savedTheme: 'dark'|'light'|null */
function applyTheme(){
  const html = document.documentElement;
  html.classList.remove('theme-dark','theme-light');
  if(savedTheme === 'dark') html.classList.add('theme-dark');
  else if(savedTheme === 'light') html.classList.add('theme-light');
  else {
    // follow system preference
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    if(prefersDark) html.classList.add('theme-dark');
    else html.classList.add('theme-light');
  }

  // set icon: show sun if currently dark (click will switch)
  const isDark = html.classList.contains('theme-dark');
  document.getElementById('themeToggle').textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ™';
}

/* toggle theme cycle: null -> dark -> light -> null */
document.getElementById('themeToggle').addEventListener('click', () => {
  if(savedTheme === null) savedTheme = 'dark';
  else if(savedTheme === 'dark') savedTheme = 'light';
  else savedTheme = null;
  applyTheme();
  saveState();
});

/* ------------------------------
   Actions menu
   ------------------------------ */
function toggleActions(){
  const m = document.getElementById('actionsMenu');
  m.style.display = m.style.display === 'block' ? 'none' : 'block';
}
document.addEventListener('click', e => {
  if(!e.target.closest('.actions-container') && !e.target.closest('#actionsMenu') && !e.target.closest('button.icon-btn')) {
    document.getElementById('actionsMenu').style.display = 'none';
  }
});

/* ------------------------------
   Player setup UI
   ------------------------------ */
function addPlayerInput(name = ''){
  const container = document.getElementById('playerInputs');
  const row = document.createElement('div');
  row.className = 'player-input-row';
  const safe = escapeHtml(name);
  row.innerHTML = `<input class="player-name" placeholder="Player name" value="${safe}">`;
  container.appendChild(row);
}

/* Escape helper */
function escapeHtml(s = '') {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

/* ------------------------------
   Start / Render
   ------------------------------ */
function startGame(){
  const inputs = document.querySelectorAll('.player-name');
  players = [];
  scores = {};
  history = [];

  inputs.forEach(inp => {
    const n = inp.value.trim();
    if(n){
      players.push(n);
      scores[n] = 0;
    }
  });

  if(players.length === 0){
    alert('Please add at least one player name.');
    return;
  }

  // initial round 0 snapshot of zeros
  const zeros = players.map(() => 0);
  history = [zeros];

  document.getElementById('setup').style.display = 'none';
  document.getElementById('game').style.display = 'block';
  renderPlayerRows();
  updateAll();
  saveState();
}

function renderPlayerRows(){
  const tbody = document.getElementById('playerRows');
  tbody.innerHTML = '';

  const order = sortedPlayers();
  order.forEach((p, displayIdx) => {
    const origIdx = players.indexOf(p);
    const color = COLORS[origIdx % COLORS.length];
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="col-name">
        <span class="color-dot" style="background:${color}"></span>
        <span style="vertical-align:middle">${escapeHtml(p)}</span>
      </td>
      <td class="col-input">
        <input id="points-${encodeId(p)}" class="numeric-input" inputmode="numeric" pattern="[0-9]*" placeholder="0">
      </td>
      <td class="col-total" id="total-${encodeId(p)}">${scores[p] ?? 0}</td>
    `;
    tbody.appendChild(tr);
  });

  // sync sort icons look
  const scoreIcon = document.getElementById('scoreSort');
  const nameIcon = document.getElementById('nameSort');
  if(sortMode === 'score-desc'){ scoreIcon.textContent = 'â†“'; nameIcon.textContent = 'â†“'; }
  else if(sortMode === 'score-asc'){ scoreIcon.textContent = 'â†‘'; nameIcon.textContent = 'â†“'; }
  else if(sortMode === 'name-asc'){ nameIcon.textContent = 'â†‘'; scoreIcon.textContent = 'â†“'; }
  else if(sortMode === 'name-desc'){ nameIcon.textContent = 'â†“'; scoreIcon.textContent = 'â†“'; }
}

/* encode name to id-safe */
function encodeId(s){ return btoa(unescape(encodeURIComponent(s))).replace(/=/g,''); }

/* ------------------------------
   Sorting
   ------------------------------ */
function sortedPlayers(){
  return players.slice().sort((a,b) => {
    if(sortMode === 'score-desc') return (scores[b] || 0) - (scores[a] || 0);
    if(sortMode === 'score-asc') return (scores[a] || 0) - (scores[b] || 0);
    if(sortMode === 'name-asc') return a.localeCompare(b);
    if(sortMode === 'name-desc') return b.localeCompare(a);
    return 0;
  });
}

function toggleSort(col){
  if(col === 'score'){
    sortMode = (sortMode === 'score-desc') ? 'score-asc' : 'score-desc';
  } else if(col === 'name'){
    sortMode = (sortMode === 'name-asc') ? 'name-desc' : 'name-asc';
  }
  renderPlayerRows();
  updateTotals();
  saveState();
}

/* ------------------------------
   Submit points & Rounds
   ------------------------------ */
function submitPoints(){
  if(players.length === 0) return;

  const snapshot = [];
  players.forEach(p => {
    const el = document.getElementById(`points-${encodeId(p)}`);
    let raw = '';
    if(el) raw = el.value.trim();
    const val = (raw === '' || isNaN(parseInt(raw))) ? 0 : parseInt(raw,10);
    scores[p] = (scores[p] || 0) + val;
    if(el) el.value = '';
    snapshot.push(scores[p]);
  });

  history.push(snapshot);
  updateAll();
  saveState();
}

/* ------------------------------
   Update UI + Chart
   ------------------------------ */
function updateTotals(){
  players.forEach(p => {
    const td = document.getElementById(`total-${encodeId(p)}`);
    if(td) td.textContent = scores[p] ?? 0;
  });
}

function updateChart(){
  const ctx = document.getElementById('scoreChart').getContext('2d');

  // Ensure history always has at least Round 0
  if(history.length === 0){
    history = [players.map(() => 0)];
  }

  const labels = history.map((_, i) => `Round ${i}`);

  const datasets = players.map((p, idx) => {
    const color = COLORS[idx % COLORS.length];
    // collect value at position idx from each snapshot
    const data = history.map(snapshot => snapshot[idx] ?? 0);
    return {
      label: p,
      data,
      borderColor: color,
      backgroundColor: color + '33',
      borderWidth: 2.5,
      pointRadius: 4,
      tension: 0.25
    };
  });

  if(chart) chart.destroy();
  chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets
    },
    options: {
      maintainAspectRatio: false,
      responsive: true,
      plugins: {
        legend: { labels: { color: getComputedStyle(document.documentElement).getPropertyValue('--text') || '#000' } }
      },
      scales: {
        x: { ticks: { color: getComputedStyle(document.documentElement).getPropertyValue('--text') || '#000' } },
        y: { ticks: { color: getComputedStyle(document.documentElement).getPropertyValue('--text') || '#000' }, beginAtZero: true }
      }
    }
  });
}

function updateAll(){
  renderPlayerRows();
  updateTotals();
  updateChart();
}

/* ------------------------------
   Edit rounds modal
   ------------------------------ */
function openEditRounds(){
  // create modal content
  const modalRoot = document.getElementById('modalContainer');
  modalRoot.innerHTML = '';
  modalRoot.style.display = 'block';

  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  // header + description
  modal.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center;">
      <strong>Edit Previous Rounds</strong>
      <div class="muted">Round 0..${Math.max(0, history.length-1)}</div>
    </div>
    <div style="margin-top:8px; font-size:13px; color:var(--muted)">Change any value. Round 0 should represent the initial totals (usually zeros).</div>`;

  // table
  const tbl = document.createElement('table');
  // header row
  let thead = '<tr><th>Round</th>';
  players.forEach(p => thead += `<th>${escapeHtml(p)}</th>`);
  thead += '</tr>';
  let rows = thead;

  // ensure history includes round 0; pad missing lengths
  if(history.length === 0) history = [players.map(()=>0)];
  history.forEach((snapshot, ri) => {
    rows += `<tr><td>${ri}</td>`;
    players.forEach((p, pi) => {
      const v = snapshot[pi] ?? 0;
      rows += `<td><input class="round-input" data-round="${ri}" data-player="${pi}" value="${v}" inputmode="numeric" pattern="[0-9]*"></td>`;
    });
    rows += '</tr>';
  });

  tbl.innerHTML = rows;
  modal.appendChild(tbl);

  // actions
  const actions = document.createElement('div');
  actions.className = 'modal-actions';
  const saveBtn = document.createElement('button');
  saveBtn.className = 'btn'; saveBtn.textContent = 'Save';
  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'icon-btn'; cancelBtn.textContent = 'Cancel';

  actions.appendChild(cancelBtn);
  actions.appendChild(saveBtn);
  modal.appendChild(actions);

  backdrop.appendChild(modal);
  modalRoot.appendChild(backdrop);

  // event listeners
  cancelBtn.addEventListener('click', () => {
    modalRoot.innerHTML = ''; modalRoot.style.display = 'none';
  });

  saveBtn.addEventListener('click', () => {
    // build new history from inputs (validate numbers)
    const inputs = modal.querySelectorAll('.round-input');
    // create a copy of existing history lengths
    const newHistory = history.map(s => s.slice()); // deep-ish copy
    let ok = true;
    inputs.forEach(inp => {
      const r = parseInt(inp.dataset.round,10);
      const p = parseInt(inp.dataset.player,10);
      let v = inp.value.trim();
      if(v === '' || isNaN(parseInt(v))) v = 0;
      const nv = parseInt(v,10);
      if(!Number.isFinite(nv)) ok = false;
      if(ok){
        // ensure row exists
        if(!newHistory[r]) newHistory[r] = players.map(()=>0);
        newHistory[r][p] = nv;
      }
    });

    if(!ok){
      alert('Please enter valid numbers.');
      return;
    }

    // replace history, recompute scores from last snapshot
    history = newHistory;
    // recompute scores: last entry
    const last = history[history.length-1];
    players.forEach((p, idx) => scores[p] = last[idx] ?? 0);

    // ensure at least round 0 exists
    if(history.length === 0) history = [players.map(()=>0)];

    updateAll();
    saveState();

    modalRoot.innerHTML = ''; modalRoot.style.display = 'none';
  });

  // allow backdrop click to close
  backdrop.addEventListener('click', (e) => {
    if(e.target === backdrop){
      modalRoot.innerHTML = ''; modalRoot.style.display = 'none';
    }
  });
}

/* ------------------------------
   New game & reset
   ------------------------------ */
function confirmNewGame(){
  const ok = confirm('Start a new game with the same players? This will reset totals and history but keep player names.');
  if(!ok) return;
  players.forEach(p => scores[p] = 0);
  history = [players.map(()=>0)];
  updateAll();
  saveState();
}

function confirmReset(){
  const ok = confirm('Reset everything and return to player setup? This will clear players, scores and history.');
  if(!ok) return;
  localStorage.removeItem('scorekeeper_state');
  location.reload();
}

/* ------------------------------
   Init
   ------------------------------ */
function init(){
  // load state if present
  const had = loadState();
  if(!had){
    addPlayerInput('');
    addPlayerInput('');
    applyTheme();
    return;
  }

  applyTheme();

  // if players exist, go to game view and ensure structures okay
  if(players && players.length > 0){
    // ensure scores exist for each player
    players.forEach(p => { if(scores[p] === undefined) scores[p] = 0; });
    // ensure history has at least round 0 snapshot
    if(!history || history.length === 0){
      history = [players.map(()=>0)];
    } else {
      // ensure snapshots have correct length for players; pad missing values with zeros
      history = history.map(snap => {
        const out = [];
        for(let i=0;i<players.length;i++) out.push(snap[i] ?? 0);
        return out;
      });
      // recalc scores from last snapshot
      const last = history[history.length-1];
      players.forEach((p, idx) => scores[p] = last[idx] ?? 0);
    }

    document.getElementById('setup').style.display = 'none';
    document.getElementById('game').style.display = 'block';
    renderPlayerRows();
    updateAll();
  } else {
    // no players saved: show setup with two blanks
    addPlayerInput('');
    addPlayerInput('');
  }
}

window.addEventListener('load', init);

/* keyboard enter to add points */
document.addEventListener('keypress', function(e){
  if(e.key === 'Enter' && document.getElementById('game').style.display === 'block'){
    submitPoints();
    e.preventDefault();
  }
});
</script>
</body>
</html>
